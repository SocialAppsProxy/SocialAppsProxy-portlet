package com.wordpress.metaphorm.authProxy.hook;

/**
 * Copyright (c) 2014-present Stian Sigvartsen. All rights reserved.
 *
 * This file is part of Social Apps Proxy.
 *
 * Social Apps Proxy is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Social Apps Proxy is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Social Apps Proxy.  If not, see <http://www.gnu.org/licenses/>.
 */

import com.liferay.portal.kernel.exception.PortalException;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;
import com.liferay.portal.service.ServiceContext;
import com.wordpress.metaphorm.authProxy.OAuthProviderConfigurationException;
import com.wordpress.metaphorm.authProxy.RedirectRequiredException;
import com.wordpress.metaphorm.authProxy.Utils;
import com.wordpress.metaphorm.authProxy.httpClient.AuthProxyConnection;
import com.wordpress.metaphorm.authProxy.httpClient.HttpConstants;
import com.wordpress.metaphorm.authProxy.httpClient.impl.OAuthProxyConnectionApacheHttpCommonsClientImpl;
import com.wordpress.metaphorm.authProxy.sb.NoSuchOAuthProviderException;
import com.wordpress.metaphorm.authProxy.state.ExpiredStateException;
import com.wordpress.metaphorm.authProxy.state.OAuthState;
import com.wordpress.metaphorm.authProxy.state.OAuthStateManager;
import com.wordpress.metaphorm.authProxy.state.UserToken;
import com.wordpress.metaphorm.authProxy.state.impl.PortalAuthedSessionOAuthStateImpl;
import com.wordpress.metaphorm.authProxy.state.impl.HttpSessionOAuthStateImpl;
import com.wordpress.metaphorm.authProxy.state.impl.PortalGuestSessionOAuthStateImpl;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.Map;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import oauth.signpost.exception.OAuthCommunicationException;
import oauth.signpost.exception.OAuthExpectationFailedException;
import oauth.signpost.exception.OAuthMessageSignerException;
import oauth.signpost.exception.OAuthNotAuthorizedException;

import org.apache.commons.codec.digest.DigestUtils;

/**
 * @author Stian Sigvartsen
 */
public class AuthProxyServletFilter implements Filter {

	private String PROXY_USER_AGENT = "Liferay Portal OAuth proxy";
	
	private FilterConfig filterConfig;
	
	public void destroy() {
		_log.debug("destroy()");
	}
	
	private OAuthState getOAuthState(HttpServletRequest servletReq, HttpServletResponse servletResp) throws ExpiredStateException {
		
		String userToken = servletReq.getHeader("userToken");
		if (userToken == null) { // If not provided via XForms <submission/> header ...
			// ... then a web browser is client so use the servlet session ID hashed (to protect it)

			userToken = DigestUtils.sha1Hex(servletReq.getSession().getId());
		}
		
		OAuthState oAuthState = OAuthStateManager.getOAuthState(userToken);
		
		if (oAuthState == null) { // If first interaction ...
						
			// userToken was generated by the portlet filter, now needs an OAuthState
			if (userToken.startsWith("PORTLET:")) {
				
				_log.debug("Received userToken back from portlet: " + userToken);
				
				UserToken userTokenObj = UserToken.parseFromString(userToken);
				
				if (!userTokenObj.isUntampedWith()) {
					
					_log.debug("Looks like the userToken has been tampered with!");
					throw new ExpiredStateException();
				}
				
				if (userTokenObj.userId > 0) {
					
					ServiceContext serviceContext = new ServiceContext();
					serviceContext.setCompanyId(userTokenObj.companyId);
					serviceContext.setScopeGroupId(userTokenObj.scopeGroupId);
					serviceContext.setUserId(userTokenObj.userId);
									
					PortalAuthedSessionOAuthStateImpl oAuthStateImpl = new PortalAuthedSessionOAuthStateImpl(serviceContext, servletReq.getSession());				
					OAuthStateManager.setOAuthState(userToken, oAuthStateImpl);

				} else {
					
					PortalGuestSessionOAuthStateImpl oAuthStateImpl = new PortalGuestSessionOAuthStateImpl(servletReq.getSession());				
					OAuthStateManager.setOAuthState(userToken, oAuthStateImpl);
				}
								
				oAuthState = OAuthStateManager.getOAuthState(userToken);
				
				if (userTokenObj.p_auth != null && userTokenObj.p_auth.trim().length() > 0) {
					oAuthState.setPAuth(userTokenObj.p_auth);
					_log.debug("Received p_auth parameter from portlet: " + userTokenObj.p_auth);
				}
				
			} else {
			
				// ... instantiate a new OAuthState considering a web browser as client
				// If a portlet is the client, then the portlet should have created the OAuthState by now!
				OAuthStateManager.setOAuthState(userToken, 
						new HttpSessionOAuthStateImpl(servletReq.getSession()));
				
				oAuthState = OAuthStateManager.getOAuthState(userToken);
			}
		}
		
		return oAuthState;
	}
		
	private boolean filterHttpRequest(HttpServletRequest servletReq, HttpServletResponse servletResp)
			throws IOException, ServletException,
					OAuthCommunicationException, OAuthExpectationFailedException, 
					OAuthNotAuthorizedException, OAuthMessageSignerException, ExpiredStateException, NoSuchOAuthProviderException, SystemException, OAuthProviderConfigurationException {
		
		_log.debug("doFilter()");
		
		//if (servletReq.getQueryString() != null && servletReq.getQueryString().indexOf("p_p_resource_id") == -1)
			//Utils.traceRequest(servletReq);
		
		// Prevent infinte loops by detecting when request has come from this filter
		if (servletReq.getHeader("User-Agent") != null && servletReq.getHeader("User-Agent").equals(PROXY_USER_AGENT)) {
			_log.debug("Leaving request unchanged because it came from the proxy filter (prevent infinite loop).");
			return false;
		}
		
		if (servletReq.getParameter("oauth_realm") != null
				&& servletReq.getParameter("oauth_token") != null 
				&& servletReq.getParameter("oauth_verifier") != null) {
			
			return handleOAuthCallback(servletReq, servletResp);
		}
		
		// Allow requests for standard Liferay resources to pass through
		if (Utils.isLiferayLocalResource(servletReq)) {
			
			_log.debug("Processing as local Liferay resource request");
			
			// If the request is for a local Liferay JSON resource and doesn't already contain a p_auth parameter (prevents infinite request loop!)
			if (servletReq.getRequestURI().toLowerCase().startsWith("/api/secure/jsonws/") && servletReq.getParameter("p_auth") == null) {

				_log.debug("Liferay API resource request");
				
				processLocalLiferayResourceRequest(servletReq, servletResp);
				return true;
				
			} else {			
				return false;
			}
		}
		
		return serveRequest(servletReq, servletResp);		
	}

	private boolean handleOAuthCallback(HttpServletRequest servletReq,
			HttpServletResponse servletResp) throws ExpiredStateException,
			OAuthCommunicationException, OAuthExpectationFailedException,
			OAuthNotAuthorizedException, OAuthMessageSignerException,
			NoSuchOAuthProviderException, SystemException, IOException, OAuthProviderConfigurationException {
		_log.debug("Received OAuth callback request ... ");
		
		OAuthStateManager.setReceivedVerifier(
				servletReq.getParameter("oauth_realm"), 
				servletReq.getParameter("oauth_token"), 
				servletReq.getParameter("oauth_verifier"));
		
		_log.debug("Redirecting to strip oauth_token and oauth_verifier parameters out");
		String queryString = servletReq.getQueryString();
		
		if (queryString != null) {
			_log.debug("  Before: " + queryString);
			queryString = queryString.replaceAll("&oauth_token(=[^&]*)?|^oauth_token(=[^&]*)?&?", "")
					.replaceAll("&oauth_verifier(=[^&]*)?|^oauth_verifier(=[^&]*)?&?", "")
					.replaceAll("&oauth_realm(=[^&]*)?|^oauth_realm(=[^&]*)?&?", "");
			_log.debug("  After: " + queryString);				
		}
		
		servletResp.sendRedirect(servletReq.getRequestURL() + (queryString != null && queryString.length() > 0 ? "?" + queryString : ""));
		return true;
	}

	private boolean processLocalLiferayResourceRequest(HttpServletRequest servletReq,
			HttpServletResponse servletResp)
			throws OAuthMessageSignerException, OAuthNotAuthorizedException,
			OAuthExpectationFailedException, OAuthCommunicationException,
			IOException, MalformedURLException, UnsupportedEncodingException {
				
		OAuthState oAuthState = OAuthStateManager.getOAuthState(servletReq.getSession().getId());
		
		String url = servletReq.getRequestURL().toString();
		String queryString = servletReq.getQueryString();
		
		if (oAuthState != null) {
			
			_log.debug("Requesting local Liferay resource using p_auth from OAuthState object!");
			
			try {
				if (queryString != null) 
					queryString += "&p_auth=" + oAuthState.getPAuth(); 
				else 
					queryString = "p_auth=" + oAuthState.getPAuth();
				
			} catch (ExpiredStateException e) {
				_log.debug("Could not provide p_auth parameter enrichment");
			}
		}
		
		_log.debug("Requesting " + url + (queryString != null ? "?" + queryString : ""));
		
		HttpURLConnection uRLConn = (HttpURLConnection)new URL(url + (queryString != null ? "?" + queryString : "")).openConnection();
		uRLConn.addRequestProperty("User-Agent", PROXY_USER_AGENT);
		
		uRLConn.addRequestProperty("Cookie", "JSESSIONID=" + servletReq.getSession().getId());
		
		String transformHeader = servletReq.getHeader("transform-response-to");
		if (transformHeader == null) transformHeader = servletReq.getParameter("transform-response-to");
		
		uRLConn.connect();
		
		int httpStatusCode = uRLConn.getResponseCode();
		servletResp.setStatus(httpStatusCode);
		
		if (httpStatusCode < 200 || httpStatusCode >= 300) {
			// Return immediately for error codes
			return true;
		}
		
		InputStream in = uRLConn.getInputStream();
		
		if (transformHeader != null) {
			
			_log.debug("Transforming JSON to XML");
			
			servletResp.setContentType("application/xml");
			String json = sinkInputStream(in, servletResp.getCharacterEncoding());
			Utils.writeJSONAsXML(json, servletResp.getWriter());
			
		} else {
		
			// Proxy content type hearder
			servletResp.setContentType(uRLConn.getContentType());
			
			OutputStream out = servletResp.getOutputStream();
			
			int i;
			while ((i = in.read()) != -1) {
				out.write((byte)i);
			}
		
		}
		
		return true;
	}
	
	private boolean serveRequest(HttpServletRequest servletReq,
			HttpServletResponse servletResp)
			throws OAuthMessageSignerException, OAuthNotAuthorizedException,
			OAuthExpectationFailedException, OAuthCommunicationException,
			IOException, MalformedURLException, UnsupportedEncodingException, ExpiredStateException, OAuthProviderConfigurationException {
		
		_log.debug("Acting as forwarding proxy to " + servletReq.getServerName() + " !");
		
		// Get the oAuthState linked to the userToken (by header) or HTTP session ID
		OAuthState oAuthState = getOAuthState(servletReq, servletResp);
				
		AuthProxyConnection uRLConn = new OAuthProxyConnectionApacheHttpCommonsClientImpl(servletReq, oAuthState);

		try {
						
			String transformHeader = servletReq.getHeader("transform-response-to");
			if (transformHeader == null) transformHeader = servletReq.getParameter("transform-response-to");
			
			uRLConn.connect();
			
			servletResp.setStatus(uRLConn.getResponseCode());
			
			Map<String, List<String>> headerMap = uRLConn.getResponseHeaders();

			String acceptEncodingHeaderValue = servletReq.getHeader(HttpConstants.STRING_ACCEPT_ENCODING_HEADER_NAME);
			boolean supportGzip = acceptEncodingHeaderValue != null && acceptEncodingHeaderValue.contains("gzip");
			
			boolean gzipped = false;
			{
				List<String> contentEncoding = headerMap.get(HttpConstants.STRING_CONTENT_ENCODING_HEADER_NAME);
				if (contentEncoding != null && contentEncoding.size() == 1 && contentEncoding.get(0).contains("gzip"))
					gzipped = true;
			}
			
			boolean proxyContentUntouched = 
					(transformHeader == null && (!gzipped || (gzipped && supportGzip)));
			
			_log.debug("Preserve content length & encoding headers? " + proxyContentUntouched);
			
			for (String headerName : headerMap.keySet()) {
				
				// Discard content compression / encoding headers if the proxied response will be manipulated later
				// If so, let the Servlet container add appropriate replacement headers
				if (!proxyContentUntouched) {
					if (headerName.equalsIgnoreCase(HttpConstants.STRING_CONTENT_LENGTH_HEADER_NAME)) continue;
					if (headerName.equalsIgnoreCase(HttpConstants.STRING_CONTENT_TYPE_HEADER_NAME)) continue;
					if (headerName.equalsIgnoreCase(HttpConstants.STRING_CONTENT_ENCODING_HEADER_NAME)) continue;
				}
				
				for (String headerValue : headerMap.get(headerName)) {
					servletResp.setHeader(headerName, headerValue);
					_log.debug("  Set header \"" + headerName + "\" = \"" + headerValue + "\"");
				}
			}

			InputStream in = uRLConn.getInputStream();
			
			if (in != null) {
			
				if (transformHeader != null) {
					
					_log.debug("Transforming JSON to XML");
					
					String jsonContentType = uRLConn.getContentType();
					String jsonCharSet = (jsonContentType.indexOf("charset=") > -1 ? jsonContentType.substring(jsonContentType.indexOf("charset=") + "charset=".length()): "");
					
					_log.debug("JSON response character set was " + jsonCharSet);
				
					servletResp.setContentType("application/xml" + (jsonCharSet.length() > 0 ? "; charset=" + jsonCharSet : ""));
					String json = sinkInputStream(in, servletResp.getCharacterEncoding());
					Utils.writeJSONAsXML(json, servletResp.getWriter());
					
				} else {
					
					_log.debug("Serving response..");
									
					// Proxy content type hearder
					servletResp.setContentType(uRLConn.getContentType());
					
					OutputStream out;
										
					// No transformation necessary, attempt to proxy on Content-Length header
					
					int byteCount = 0;
					int i;
					
					if (!proxyContentUntouched) {
						
						if (gzipped) {							
							_log.debug("Proxy endpoint content is GZipped");							
							in = new GZIPInputStream(in);
						}
											
						if (supportGzip) {
						
							_log.debug("GZipping response...");
							
							servletResp.setHeader(HttpConstants.STRING_CONTENT_ENCODING_HEADER_NAME, "gzip");
							
							out = servletResp.getOutputStream();
							
							GZIPOutputStream gzipOut = new GZIPOutputStream(out);
							streamBytes(in, gzipOut, byteCount);
						
						} else {

							_log.debug("Writing an uncompressed response...");

							out = servletResp.getOutputStream();
							streamBytes(in, out, byteCount);
	
						}
						
					} else {
						
						_log.debug("Tunnelling proxy endpoint content untouched...");
						
						out = servletResp.getOutputStream();						
						streamBytes(in, out, byteCount);				
					}
					
					out.flush();
					
				}
			}
			
			return true;			
			
		} catch (RedirectRequiredException e) {
			
			if (oAuthState instanceof HttpSessionOAuthStateImpl
					|| (oAuthState instanceof OAuthStateManager.ManagedOAuthState 
							&& ((OAuthStateManager.ManagedOAuthState)oAuthState).getManagedOAuthState().equals(HttpSessionOAuthStateImpl.class))
					) { 
				_log.debug("About to issue HTTP redirect to: " + e.getURL().toString());
				servletResp.sendRedirect(e.getURL().toString());
				return true;
				
			} else {
				
				String xmlResp = "<?xml version=\"1.0\"?>"
						+ "<oauth><authorisation_needed><url>"
						+ e.getURL().toString().replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
						+ "</url></authorisation_needed></oauth>"; 
				
				_log.debug("About to write XML: " + xmlResp);
				
				servletResp.setStatus(200);
				servletResp.setContentType("application/xml");					
				servletResp.getWriter().write(xmlResp);
				return true;
			}
		}
		
	}

	private void streamBytes(InputStream in, OutputStream out, int byteCount)
			throws IOException {
		int i;
		while ((i = in.read()) != -1) {
			out.write((byte)i);
			byteCount++;
		}
		
		_log.debug("Wrote " + byteCount + " bytes");
	}
	
	public void doFilter(
			ServletRequest servletReq, ServletResponse servletResp,
			FilterChain filterChain)
		throws IOException, ServletException {
		
		if (servletReq instanceof HttpServletRequest) {
			
			HttpServletResponse httpServletResp = (HttpServletResponse)servletResp;
			
			try {
				
				// Handle potential request for HTTP resource via Social Apps Proxy
				if (filterHttpRequest((HttpServletRequest)servletReq, httpServletResp))
					return; // Don't allow any more filters or servlets to process the request.
				
				// Consider a portal request, make userToken available to plug-ins
				String userToken = UserToken.constructFromHttpServletRequest((HttpServletRequest)servletReq).toString();
				servletReq.setAttribute("userToken", userToken);
				
			} catch (OAuthCommunicationException e) {					
				throw new IOException(e);
			} catch (OAuthExpectationFailedException e) {
				throw new IOException(e);
			} catch (OAuthNotAuthorizedException e) {
				throw new IOException(e);
			} catch (OAuthMessageSignerException e) {
				throw new IOException(e);
			} catch (ExpiredStateException e) {
				throw new ServletException(e);
			} catch (NoSuchOAuthProviderException e) {
				throw new IOException(e);
			} catch (SystemException e) {
				throw new ServletException(e);			
			} catch (OAuthProviderConfigurationException e) {
				httpServletResp.sendError(501, e.getMessage());
				return;
			} catch (PortalException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return;
			}	
		}
		
		filterChain.doFilter(servletReq, servletResp);
	}

	public void init(FilterConfig filterConfig) {
		
		_log.debug("init()");
		
		// Hash Secret is read from web.xml so that each installation of Social Apps Proxy
		// can use a different value, yet the same value for all nodes in a cluster

		String secret = filterConfig.getInitParameter("hashSecret");
		
		_log.debug("hashSecret set to \"" + secret + "\" using liferay-hook.xml");
		
		if ("change-me-to-something-random".equals(secret))
			_log.warn("IMPORTANT: You should set hashSecret (see liferay-hook.xml) to a value other than the default before using Social Apps Proxy in production. Failing to do so may leave your portal vulnerable to user impersonation.");
		
		UserToken.secret = secret;
		
		this.filterConfig = filterConfig;
	}
	
	
	private String sinkInputStream(InputStream stream, String charsetName) throws UnsupportedEncodingException, IOException {
		
		StringBuilder sb = new StringBuilder();
		BufferedReader br = new BufferedReader(new InputStreamReader(stream));//, charsetName));
		
		String line;
		while ((line = br.readLine()) != null) {
			sb.append(line);
		}

		return sb.toString();
	}
	
	private static Log _log = LogFactoryUtil.getLog(AuthProxyServletFilter.class);

}
